## Critical Connections in a Network

### Условие
There are n servers numbered from 0 to n - 1 connected by undirected server-to-server connections forming a network where connections[i] = [ai, bi] represents a connection between servers ai and bi. Any server can reach other servers directly or indirectly through the network.

A critical connection is a connection that, if removed, will make some servers unable to reach some other server.

Return all critical connections in the network in any order.

### Решение
В данном графе нужно найти все мосты.
Алгоритм будет основан на обходе в глубину.
Утверждение: ребро `(from, to)` является мостом тогда и только тогда, когда
оно принадлежит дереву обхода и из поддерева `to` нет ребер, которые идут в предка
вершины `from` или саму вершину `from`.

`=>` 
- Если ребро не принадлежит дереву, то его удаление не нарушает связности графа,
а значит это был бы не мост. Следовательно мост лежит в дереве обхода.
- Пусть есть ребро `(child, ancestor)`, тогда мост лежит в цикле 
- `child -> ancestor ~> from -> to ~> child`, а значит его удаление не нарушает связности графа,
  а значит это был бы не мост. Следовательно мост лежит в дереве обхода.

`<=`
Если удалить `(from, to)` из графа, то ни одна вершина-предок `from` и сама вершина 
`from` не будут достижимы из поддерева `to`, т.к. по предположению таких ребер нет.
А значит количество компонент связности увеличилось, а значит ребро `(from, to)` - мост.

Для того, чтобы проверять данное условие при обходе в глубину заведем величину
`fup[v]`, которая хранит время посещения наиболее "старшего" предка достижимого 
из поддерева вершины`v`. Обновлять ее значение будем рекурсивно 
через соответствующие значения детей. При первом посещении вершины `v` будем полагать, что
 `fup[v] = in[v]`, где `in[v]` - это время посещения вершины `v`.
Впоследствии это значение может либо уменьшиться, либо не измениться. 

Запускаем DFS из некоторой вершины. Опишем шаг DFS для некоторой вершины `v`.
Обходим все вершины `to` достижимые из `v`, они могут быть либо посещены, либо непосещены.

Если вершина посещена, то это предок (перекрестных ребер быть не может, т.к. иначе `v`
уже была бы посещена в другой ветке DFS). Если предок - это родитель, то ничего не делаем.
Иначе можно обновить `fup[v]`, если `in[to] < fup[v]`, т.е. берем `min(in[to], fup[v])`.

Если вершина непосещена, то это ребенок и запускаем для нее DFS, в итоге для нее будет посчитан.
И теперь нужно снова обновить `fup[v]`, т.к. из какой-то вершины в поддереве могло быть ребро
"выше" того, которое мы сейчас храним, поэтому берем `min(fup[to], fup[v])`.

Если после этого значение `fup[to] == in[to]`, то значит в поддереве `to` нет ребер идущих
к предкам, а значит по критерию ребро `(v, to)` - мост.

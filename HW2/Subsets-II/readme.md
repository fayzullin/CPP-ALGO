## Generate Parentheses

### Условие
Given an integer array nums that may contain duplicates, return all possible subsets (the power set).

The solution set must not contain duplicate subsets. Return the solution in any order.

### Ограничения
- $1 <= nums.length <= 10$
- $-10 <= nums[i] <= 10$

### Решение
В решении реализован рекурсивный алгоритм генерации подмножеств.

```c++
class Solution {
public:
    
    Solution() : result(1) {}
    
    vector<vector<int>> subsets(vector<int>& nums) {
        generateSubset(nums, {}, 0);
        return result;
    }
    
private:
    void generateSubset(vector<int>& nums, vector<int> currSubset, int currPos)
    {
        if (currPos == nums.size())
        {
            return;
        }
        
        vector<int> subsetWithNextElem = currSubset;
        subsetWithNextElem.push_back(nums[currPos]);
        result.push_back(subsetWithNextElem);
        
        generateSubset(nums, std::move(subsetWithNextElem), currPos + 1);
        generateSubset(nums, std::move(currSubset), currPos + 1);
    }
    
        
private:
    vector<vector<int>> result;
};
```

Выше приведена реализация алгоритма для генерации всех подмножеств некоторого набора элементов.
Изначально в ответ добавляем пустое множество.
Каждый из элементов можно либо взять, либо пропустить, при этом на каждом шаге добавления элемента в подмножество, добавляем полученное подмножество в ответ.
Таким образом каждая ветка исполнения содержит `nums.size()` шагов. Т.к. мы проходим по всем элементам и по всем вариантам - взять/не взять, то получаем все возможные подмножества.

Осталось понять, почему добавленные ограничения позволяют избавиться от повторнеия одинаковых подмножеств в случае набора с повторяющимися элементами в исходном наборе.

В случае с повторяющимися элементами будем также запоминать был ли добавлен предыдущий элемент для данной ветки исполнения.
Пропускать элементы можно без проверок, т.к. если до текущего шага все подмножества были уникальными и с учетом того, что ответ пополняется только при добавлении элемента, то при пропуске текущего элемента не появляется повторяющихся множеств.

Перед тем, как взять очередной элемент (а значит добавить полученный результат в ответ и запустить новую ветвь исполнения), нужны проверки, т.к. могут появиться повторяющиеся подмножества.

Проблема заключается в том, что если мы в одной ветви исполнения взяли первый повторяющийся элемент, а во втором второй, то получим повторение, т.е. нужно исключить подобную ситуацию, а именно не заходить во вторую и далее ветви исполнения, порожденные не первыми повторяющимися элементами. 
Для этого достаточно проверить, что на предыдущем шаге был такой же элемент (изначально отсортировали все элементы) и что мы его не взяли, чтобы исключить проблемную ветвь. Также учесть случаи первого элемента массива. После данной фильтраци получим только уникальные подмножества исходного набора.



## Generate Parentheses

### Условие
Given a collection of numbers, nums, that might contain duplicates, return all possible unique permutations in any order.

### Ограничения
- $1 <= nums.length <= 10$
- $-10 <= nums[i] <= 10$

### Решение
В решении реализован рекурсивный алгоритм генерации перестановок.

```c++
class Solution {
public:
    vector<vector<int>> permute(const vector<int>& nums) {        
        vector<vector<int>> permutations;
        
        if (nums.size() == 1 )
        {
            permutations.push_back(nums);
            permutations.back().reserve(permutationSize);
            return permutations;
        }
        
        for (int i = 0; i < nums.size(); ++i)
        {
            vector<int> less_nums = copy_and_erase(nums, i);
            vector<vector<int>> less_nums_permutations = permute(less_nums);
            
            for (auto& less_nums_permutation : less_nums_permutations)
            {
                less_nums_permutation.push_back(nums[i]);
                permutations.push_back(std::move(less_nums_permutation));
            }
        }
        
        return permutations;
    }
private:
    int permutationSize;
    
    vector<int> copy_and_erase(const vector<int>& nums, int pos)
    {
        vector<int> result = nums;
        result.erase(result.begin() + pos);
        return result;
    }
};
```

Выше приведена реализация алгоритма для генерации всех перестановок некоторого набора элементов.
Реализовано следующее : в цикле ставим каждый из элементов на последнее место и 
рекурсивно генерируем все перестановки для оставшихся элементов, которые ставим в начало.
Докажем при помощи ММИ, что генерируются все перестановки. 

Для набора из одного элемента - верно (это и есть условие остановки рекурсии).
Корректность перехода докажем исходя из мощностных соображений. 
Для `k-1` элемента есть `(k-1)!` перестановок, при этом при переходе генерируются неповторяющиеся перестановки, т.к. для каждого шага цикла первый элемент отличается, а уникальность в рамках одного шага гарантируется уникальностью перестановок для меньшего набора (по предположению). В цикле `k` шагов, а значит получили `k*(k-1)! = k!` перестановок, т.е. получены все перестановки. По аксиоме математической индукции получили корректность алгоритма.

Для случая с повторяющимися элементами вначале отсортируем элементы, чтобы одинаковые шли подряд и вынесем логику в отдельный метод.
Также добавили некоторые ограничение для отсечения лишних веток исполнения рекурсии, на которых генерируются повторяющиеся перестановки.

Добавлена следующая проверка : пропускаем шаг цикла, если текущий элемент совпадает с предыдущим. В случае двух повторяющихся элементов, если сгенерированы перестановки с постановкой первого элемента в начало перестановки, то постановка второго даст аналогичные перестановки, поэтому данное ограничение оставит только уникальные перестановки. Аналогичное соображения для нескольких оджинаковых элементов, только для них транзитивно получится, что достаточно выполнения алгоритма для первого из элементов.

Также добавил резервирование памяти, чтобы при `push_back`-ах не было переаллокаций.